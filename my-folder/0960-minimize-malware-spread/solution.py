class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        N = len(graph)
        uf = UF(N)
        
        for j, row in enumerate(graph):
            for i in range(j):
                if row[i]:
                    uf.union(i, j)
                    
        count = collections.Counter(uf.find(x) for x in initial)
        ans = (0, min(initial))
        for node in initial:
            root = uf.find(node)
            if count[root] == 1:
                if uf.size(root) > ans[0]:
                    ans = (uf.size(root), node)
                elif uf.size(root) == ans[0] and node < ans[1]:
                    ans = (uf.size(root), node)
                    
        return ans[1]
    
class UF:
    
    def __init__(self, n):
        self.parient = list(range(n))
        self.sz = [1]*n
    
    def find(self, x):
        if self.parient[x] != x:
            self.parient[x] = self.find(self.parient[x])
        return self.parient[x]
    
    def union(self, x, y):
        p_x = self.find(x)
        p_y = self.find(y)
        if p_x != p_y:
            if self.sz[p_x] < self.sz[p_y]:
                self.parient[p_x] = p_y
                self.sz[p_y] += self.sz[p_x]
            else:
                self.parient[p_y] = p_x
                self.sz[p_x] += self.sz[p_y]
    
    def size(self, x):
        return self.sz[self.find(x)]
    
